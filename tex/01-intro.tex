\chapter{Introduction}

New sequencing technologies are producing more and more biological data (mostly
the genomic sequences) and therefore the automated analysis of such data is
necessary and it is important to developing such tools. In this thesis we focus
on the computational methods for comparative analysis and annotation of
biological sequences. We propose new methods for sequence annotation and
sequence alignment. We also study the computational complexity of various
algorithms for hidden Markov models and give proofs of NP-hardness for some of
them.

\section{Introduction for Computer Scientist}

We try to explain the sequence annotation and the sequence alignment from the
computational scientist perspective. We work with generative probabilistic
models, the \abbreviation{hidden Markov Models}{HMM} and their variants. In
general, HMMs are state machines that generates sequence (string) along the
sequence of states (called state path) that was used for generating the
sequence. Since HMM is an probabilistic model, it also defines the probability
of the sequences and the state paths. The state path contain the information
about the structure of the generated sequence. In practice we are given the
generated sequence and the state path is hidden. The goal of the decoding
algorithm is to reverse the generation process and obtain the original state
path or at least its approximation.

In the sequence annotation, we group the states of HMM into several classes
(called labels, or colors) and the state path into sequence of labels,
abstracting from the specific details of the generation process.  Advantage of
using a probabilistic model is that apart from the distribution of the
sequences and state paths, we also obtain the distribution of the annotations.
Decoding algorithm can also recover only an annotation, marginalizing the state
paths with the same annotation.

When using HMMs for annotation of the biological sequences, we construct HMM in
a way, that the structure of states corresponds to the biological features we
are interested in (feature is usually the biological function of the sequence).
One feature can be encoded in several states, and in such case might want to
label such states with the same label (they belong to same class).  Then we use
the decoding algorithm to obtain the state path or an annotation in such a way,
that the result is as close as possible to the true state path or an
annotation. Traditionally used decoding algorithm is the Viterbi algorithm
\cite{Durbin1998}, but other optimization criteria can be used to obtain more
accurate\footnote{Where an accuracy is a some measure that depends on the
application domain.} results \cite{Brown2010, Gross2007, Nanasi2010,
Truszkowski2011}. In Chapter \ref{CHAPTER:TWOSTAGE} we study the special type
of decoding algorithms: two stage algorithms. We show that using two-stage
algorithms can improve the results of decoding algorithms (as far we know, such
algorithms are usually used for reducing the running time). We also study the
computational complexity of some decoding criteria and show NP-hardness results
for obtaining the optimal alignments using these criteria. Namely we study the
most probable footprint problem, the problem of the most probable set problem
and the most probable restriction problem. These problems can be used as an
first stage in two-stage algorithms.

The other problem we study, the sequence alignment, is the fundamental problem
in the computational biology, and many methods, like comparative analysis
methods relies on the sequence alignment. Since biases in the underlying
alignment introduce artefacts in the results of these methods, there is need to
develop algorithms for producing sequence alignment with as low error rate as
possible. Alignment is data structure that represents biological comparison of
two or more sequences. Sequence alignment is obtained by adding gap symbols
($-$) into the sequences so that they have the same length and form
2-dimensional array or a matrix, where each sequence is in its own row.  Goal
is to put homologous (for now it means related, or just similar) parts of the
sequences into the same columns. There are many ways to insert gaps into
sequence to form alignment, and most of the alignments are not align related
parts of the sequences together. To choose the biologically correct alignment,
the scoring schemes are used; the goal of a scoring scheme is to assign high
score to the correct alignment and low score to incorrect. In practice the
scoring schemes are similar to the edit distance with custom scoring matrix for
matches, mismatches, and gap symbols. 

Scoring schemes can be also defined using \abbreviation{pair hidden Markov
models}{pHMM}.  pHMM is generative probabilistic model that generate pairs of
sequences along with their alignment (alignment is defined by a state path).
This model is the extension of HMM. In chapter \ref{CHAPTER:REP} we introduce
model that incorporates the repetitive elements that are prevalent in the
biological sequences (called tandem repeats), and propose several decoding
methods to be used with this model. Our repeat-aware method reduces the error
rate in the simulated experiments. 

\section{Biological Introduction}\label{SECTION:BIOINTRO}

In this section we review several biological terms that will be needed. More
information about DNA, proteins and genes can be found in
\cite{BiologyForDummies, UnderstandingBioinformatics}. Every cell of living
organisms contains one or several \firstUseOf{DNA} molecules. DNA is a double
stranded molecule consisting of two long sequences (strands) of
\firstUseOf{nucleotides} (nucleotides are also referred to as bases or
\firstUseOf{residues}). There are four types of nucleotides in DNA: adenosine,
cytosine, guanine, and thymine represented by letters $A,C,G$ and $T$
respectively. In RNA nucleotide $T$ is replaced with uracil, denoted by $U$.
The strands in DNA are complementary. The nucleotides at the same position in
the two strands are connected by hydrogen bonds and are complementary: $A$ is
always connected with $T$ and $C$ is always connected with $G$. Therefore we
can represent DNA molecule by a sequence over alphabet $\{A,C,G,T\}$ since the
complementary strand can be easily computed.

DNA encodes \firstUseOf{proteins}. Proteins play an important role in cell
biology since  they regulate many processes in the cell and are catalysts to
many chemical reactions. Proteins are sequences of \firstUseOf{amino acid}
molecules. There are $20$ amino acids that can be encoded in DNA. Parts of DNA
that encode proteins are called \firstUseOf{genes} (gene is ``substring'' of
DNA that will be translated into one protein). We refer to the DNA
molecule/sequence of the organism as to its \firstUseOf{genome}.

The sequence of DNA, RNA and protein molecule is called the primary structure.
There are also the secondary and ternary structures, which corresponds to two
and three dimensional positions of particular sequence symbols. In this thesis
we will consider only the primary structure of the biological sequences and we
will ignore the way these molecules are folded in space.

The rational behind sequence alignment to represent the evolution of two
sequences; according to the evolution theory, currently living organisms
evolved from single common ancestor through small changes in the genome of the
organisms. There are many types of changes, from the small scales like
substitutions (change of the nucleotide at some position, also called
mutations), insertions and deletions of sequences from and to the genomic
sequence. Other changes includes duplications (subsequence is copied into
different part of the genome), inversions (the subsequence is inverted), and
even large genome rearrangements (the large subsequences of the genome change
their position within genome). 

The speciation is event, when the new species is created. This happens mostly
due to physical separation of populations of the same organism, and each
population evolve differently to the point, that the state that they form
different species. We can represent the evolution of species using a binary
tree. Each leaf represent current organism, each internal vertex represents
speciation event, and root represents the common ancestor of all organisms in
the tree. The branch lengths usually corresponds to the amount of changes in
the genome, or to the time. 

We say that two parts of the biological sequences $X$ and $Y$ are
\firstUseOf{homologous}, if they originates from the same sequence in the
common ancestor $A$ of $X$ and $Y$. We distinguish between two types of a
homologs: orthologs and paralogs. The orthologs are two different sequences
that evolved from the common ancestor sequence by speciation event. The
paralogs are two different sequences that evolved by duplication event within
same organism ($X$ or $Y$). We want to distinguish between homologous and
non-homologous parts of the sequences. When aligning two related sequences
(they share common ancestor), we want to align homologous parts of the
sequences (specifically, we are interested in orthologs). The homologous
sequences has higher sequence similarity than non-homologous sequences,
although if the evolutionary distance (time, number of mutations) is too high,
the sequence similarity might be as low as for two random sequences.


\section{Thesis outline}

\todo{Sem chcem napisat ake budu nase prinosy}

In the second chapter we survey the relevant literature and describe the
necessary models and algorithm for sequence alignment and sequence annotation.
We cover the hidden Markov models and their variants, various decoding
algorithms used for sequence annotation, the sequence alignment problem and the
pair hidden Markov models that are used for sequence alignment.  In the end of
the second chapter we discuss algorithmic improvements to the discussed
algorithms.

The third and fourth chapters contains our results. In the third chapter we
study the two-stage algorithms. We formalize the definition of such algorithms
and show practical example of such decoding algorithm design. Then we study the
computational complexity of three problems: the most probable set, the most
probable footprint and the most probable restriction. We prove that the first
problem is NP-hard and for the latter two we prove that they are NP-hard. \todo{
+ experiment a co sme s nim mohli dosiahnut: ze two-stage nemusi byt len 
optimalizacia, ale aj zrychlenie
}

In the fourth chapter we propose tractable method for aligning sequence with
tandem repeats. We extend this notion to the most \todo{Co sme spravili}i

\section{Notation}

In this section we summarize notation used in the following
chapters.

All sequences, members of sets, vectors, and rows and columns of matrices will
be indexed from $0$. We will use mostly right-open intervals: $I=[a,b)$ means
that $a\in I$, but $b\notin I$. 

The element at the $k$-th position (zero based) of string (or sequence) $s$ will
be written as $s[k]$. The substring $s[i]s[i+1]\dots s[j-1]$ is denoted
$s[i:j]$.  If $n$ is the length of the string $s$ then $s[:i]$ is equivalent to
$s[0:i]$ and $s[i:]$ is equivalent to $s[i:n]$.  We will use the terms sequence
and string interchangeably.

Let $M$ be a matrix. Then $M[i,j]$ is the element from the $i$-th row and $j$-th
column of $M$ (indices are zero based). Similarly as for strings, submatrix
$M[i:j,k:l]$ is a matrix consisting from the intersection of rows $i,i+1,\dots,
j-1$ with columns $k,k+1,\dots,l-1$. If $M$ is of size $n\times m$ then
$M[:i,j:]$ is equivalent to $M[0:i,j:m]$.  The term $M[i,:]$ is equivalent to
$M[i,0:m]$ which is the $i$-th row of $M$.
