\chapter{Introduction}

New sequencing technologies are producing more and more biological data,
including genomic sequences of many species. Therefore it is important to
develop tools for automated analysis of such data. In this thesis we focus on
computational methods for sequence annotation and sequence alignment.  In the
sequence annotation problem, we want to label parts of the sequences according
to their function, or meaning. We call
such a labeling an \firstUseOf{annotation}. For example,  we 
can label each symbol of a genomic sequence base on whether it is part of a
gene or not as in the following example ($g$ is a label representing genes and $n$ is a label for non-gene parts).
\begin{verbatim}
Sequence:     ACGGTGCGTTAGCTGCTCTGATGTCTTCGATCTAGCTAGT 
Annotation:   nnnnnnnngggggggggggggggggggnnnnnnnnnnngg
\end{verbatim}
The \firstUseOf{sequence alignment} is a data structure
that characterizes similarity or shared origin of two or more sequences.
We insert gap symbols (dashes) so that corresponding parts of the sequence are in the same column as in the following
example.
\begin{verbatim}
Sequence X:   CTGCTAGCTACGT--GTGT
Sequence Y:   ---------ACGTGGAT--
\end{verbatim}
Both annotation and alignment are fundamental bioinformatics problems. 
The first stages of analysis of newly 
sequences genomes typically include aligning it with the genomes of related 
species (that is already sequenced), and searching for known structures (like genes) inside
new genomes.
Many subsequent methods for analysing genomes rely on sequence
annotation and alignment. To avoid artefacts in the results of
these downstream methods, there is need to develop algorithms for producing sequence
annotation and alignment with as low error rate as possible.
Tools for both
sequence annotation and alignment are often based on hidden Markov models (HMMs)
\cite{Durbin1998,Alexanderson2004,Brejova2005, FEAST2011,Krogh2001,Majoros2005,
Meyer2002,Nanasi2010,Pairagon2009, Schultz2006,Kovac2012,Pachter2002,
Liu2010,Brown2010, Lunter2008}.  In this thesis we propose new techniques for
use of HMMs  in these domains and also give proofs of NP-hardness for several related problems.

We work with generative probabilistic models, \abbreviation{hidden Markov
Models}{HMM} and their variants. In general, an HMM is a state machine that
generates a sequence (string) along with a sequence of states (called state path).
Since an HMM is a probabilistic model,
it also defines the probability of sequences and state paths. The state
path contains information about the structure of the generated sequence. In
practice we are often given the generated sequence and the state path is hidden. The
goal of the decoding algorithm is to reverse the generation process and obtain
the original state path or at least its approximation.

When using HMMs for annotation of biological sequences, we construct the
HMM so  that the structure of the states corresponds to the biological features we
are interested in.
Each feature can be encoded in one or several states.  Then we assume that the genomic sequence of interest was generated by our model and use a decoding
algorithm to obtain a state path which is as close as possible to the true
state path. The Viterbi algorithm
\cite{Durbin1998} is traditionally used for decoding, but other optimization criteria can be used to obtain more
accurate results \cite{Brown2010, Gross2007, Nanasi2010, Truszkowski2011}. Note that 
accuracy measures may depend on the application domain.  In Chapter
\ref{CHAPTER:TWOSTAGE} we study a special type of decoding algorithms: two-stage 
algorithms. In the first stage, the algorithm infers important aspects of
the annotation and in the second stage it fills remaining details in a way
consistent with the first-stage results.  We show that  two-stage
algorithms can improve the accuracy of decoding (as far we know, such
algorithms were previously used only for reducing the running time). We also
study the computational complexity of several decoding criteria appropriate for
the first stage and we show NP-hardness results for obtaining the optimal
annotations using these criteria. Namely we study the most probable footprint
problem, the most probable set problem and the most probable restriction
problem. 

In sequence alignment, the goal is to search for
corresponding  parts of the sequences and arrange them into same position in the
alignment.  To choose the biologically correct alignment, we usually optimize some
scoring scheme. We will consider scoring schemes which are  defined using
\abbreviation{pair hidden Markov models}{pHMM}. A pHMM generates pairs of
sequences along with their alignment (an alignment is defined by the state
path).  This model is an extension of HMM. 


In the fourth chapter we propose a tractable method for aligning sequences with
tandem repeats. A tandem repeat consists of consecutive copies (not exact) of a
certain motif (short genomic sequence). Tandem repeats cause problems with
sequence alignments because it is hard to distinguish between individual copies of the motif.
We extend a traditional pHMM model for sequence alignment by additional states
modeling tandem repeats. We also propose new decoding algorithms tailored to
this model. We show on simulated data that our new model and decoding methods
decrease the error rate, and with a particular increase of accuracy near the border of tandem repeats.

\section{Biological Background}\label{SECTION:BIOINTRO}

In this section we review several biological terms that will be needed. More
information about DNA, proteins, and genes can be found in
\cite{BiologyForDummies, UnderstandingBioinformatics}. Practically every cell of living
organisms contains one or several \firstUseOf{DNA} molecules. DNA is a double
stranded molecule consisting of two long sequences (strands) of
\firstUseOf{nucleotides} (nucleotides are also referred to as bases or
\firstUseOf{residues}). There are four types of nucleotides in DNA: adenosine,
cytosine, guanine, and thymine represented by letters $A,C,G$ and $T$
respectively. In RNA nucleotide $T$ is replaced with uracil, denoted by $U$.
The nucleotides at the same position in
the two strands are connected by hydrogen bonds and are complementary: $A$ is
always connected with $T$ and $C$ is always connected with $G$. Therefore we
can represent DNA molecule by a sequence over alphabet $\{A,C,G,T\}$, since the
complementary strand can be easily computed.

Some parts of DNA encode \firstUseOf{proteins}. Proteins play an important role in cell
biology since  they regulate many processes in the cell and are catalysts to
many chemical reactions. Proteins are sequences of \firstUseOf{amino acid}
molecules. There are $20$ amino acids that can be encoded in DNA. Parts of DNA
that encode proteins are called \firstUseOf{genes} (gene is ``substring'' of
DNA that will be translated into one protein). We refer to the DNA
sequences of an organism as to its \firstUseOf{genome}.

The rational behind sequence alignment is to represent the evolution of two
sequences. According to the evolution theory, currently living organisms
evolved from a single common ancestor through small changes in their genomes.
There are many types of changes.  Substitutions change  a nucleotide at some
position to another nucleotide.  Insertions and deletions add or remove parts
of the genomic sequence. Other changes includes duplications (a region of a
sequence is copied into a different part of the genome), inversions (a region
of the sequence is inverted), and even large genome rearrangements (large
regions  change their position within the genome). 

The speciation is an event, when a new species is created. This happens mostly
due to physical separation of populations of the same species. Subsequently, each
population evolves differently to a point, that they form
different species. We can represent the evolution of a set of species using a binary
tree. Each leaf represents a current species, each internal vertex represents
a speciation event, and the root represents the common ancestor of all species in
the tree. The branch lengths usually correspond to the amount of changes in
the genome or to the time. 

We say that two parts of biological sequences $X$ and $Y$ are
\firstUseOf{homologous}, if they originate from the same sequence in some
common ancestor of $X$ and $Y$. Due to their common origin, homologous sequences are often similar.
However high evolutionary
distance may cause the sequences to diverge so much that the sequence
similarity is as low as for two random sequences.

As we mentioned in the previous section, an alignment is a data structure that
represents sequences and their relation through some evolutionary changes
(substitutions, insertions and deletions).  It is obtained by adding gap
symbols ($-$) into the sequences so that they have the same length and form a
2-dimensional array or a matrix, where each sequence is in its own row. When
aligning two homologous sequences, we want to place
homologous parts of the sequences into the same columns.

Additionally, we distinguish between two types of homologs: orthologs and
paralogs. The orthologs are two different sequences that originated from the
common ancestor sequence by a speciation event. The paralogs are two different
sequences that evolved by duplication event within the same organism. The
distinction is important when aligning repetitive regions; we want to align
orthologous copies of the motif, but the paralogous copies are very similar, and it is very
hard to distinguish between paralogous and orthologous copies.

\section{Notation}

In this section we summarize notation used in the following
chapters.

All sequences, members of sets, vectors, and rows and columns of matrices will
be indexed from $0$. We will use mostly right-open intervals: $I=[a,b)$ means
that $a\in I$, but $b\notin I$. 

The element at the $k$-th position (zero based) of string (or sequence) $s$ will
be written as $s[k]$. The substring $s[i]s[i+1]\dots s[j-1]$ is denoted
$s[i:j]$.  If $n$ is the length of the string $s$ then $s[:i]$ is equivalent to
$s[0:i]$ and $s[i:]$ is equivalent to $s[i:n]$.  We will use the terms sequence
and string interchangeably.

Let $M$ be a matrix. Then $M[i,j]$ is the element from the $i$-th row and $j$-th
column of $M$ (indices are zero based). Similarly as for strings, submatrix
$M[i:j,k:l]$ is a matrix consisting from the intersection of rows $i,i+1,\dots,
j-1$ with columns $k,k+1,\dots,l-1$. If $M$ is of size $n\times m$ then
$M[:i,j:]$ is equivalent to $M[0:i,j:m]$.  The term $M[i,:]$ is equivalent to
$M[i,0:m]$ which is the $i$-th row of $M$.
