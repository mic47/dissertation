\chapter{Introduction}

New sequencing technologies are producing more and more biological data,
including genomic sequences of many species. Therefore it is important to
develop tools for automated analysis of such data. In this thesis we focus on
computational methods for sequence annotation and sequence alignment.  In the
sequence annotation problem, we want to label parts of the sequences according
to their function, meaning, or whether it holds some property or not. We call
such labeling an \firstUseOf{annotation}. For example, if we are interested in
gene finding, we label each base of a genomic sequence whether it is
gene or not as in the following example ($g$ is gene and $n$ is not gene).
\begin{verbatim}
Sequence:     ACGGTGCGTTAGCTGCTCTGATGTCTTCGATCTAGCTAGT 
Annotation:   nnnnnnnngggggggggggggggggggnnnnnnnnnnngg
\end{verbatim}
The \firstUseOf{sequence alignment} is a data structure
that characterizes a way of arranging of sequences according their
similarity, function or an origin.  Usually, we want to arrange sequences in
a way that corresponds to their evolution.  Tools for both
sequence annotation and alignment are often base on hidden Markov models (HMMs)
\cite{Durbin1998,Alexanderson2004,Brejova2005, FEAST2011,Krogh2001,Majoros2005,
Meyer2002,Nanasi2010,Pairagon2009, Schultz2006,Kovac2012,Pachter2002,
Liu2010,Brown2010, Lunter2008}.  In this thesis we propose new techniques for
use HMMs and also give proofs of NP-hardness for several related problems.

We work with generative probabilistic models, \abbreviation{hidden Markov
Models}{HMM} and their variants. In general, an HMMs is a state machine that
generates a sequence (string) along a sequence of states (called state path)
that was used for generating the sequence. Since an HMM is probabilistic model,
it also defines the probability of the sequences and the state paths. The state
path contains information about the structure of the generated sequence. In
practice we are given the generated sequence and the state path is hidden. The
goal of the decoding algorithm is to reverse the generation process and obtain
the original state path or at least its approximation.

When using HMMs for annotation of the biological sequences, we construct the
HMM so  that the structure of states corresponds to the biological features we
are interested in (feature is usually the biological function of the sequence).
Each feature can be encoded in one or several states.  Then we use a decoding
algorithm to obtain a state path which is as close as possible to the true
state path. Traditionally used decoding algorithm is the Viterbi algorithm
\cite{Durbin1998}, but other optimization criteria can be used to obtain more
accurate results \cite{Brown2010, Gross2007, Nanasi2010, Truszkowski2011}. An
accuracy is a some measure that depends on the application domain.  In Chapter
\ref{CHAPTER:TWOSTAGE} we study a special type of decoding algorithms: two
stage algorithms. In the first state, algorithm infers an important aspects of
the annotation and in the second stage it fill in remaining details in a way
consistent with the first-stage results.  We show that using two-stage
algorithms can improve the results of decoding algorithms (as far we know, such
algorithms were previously used only for reducing the running time). We also
study the computational complexity of some decoding criteria appropriate for
the first stage and show NP-hardness results for obtaining the optimal
alignments using these criteria. Namely we study the most probable footprint
problem, the most probable set problem and the most probable restriction
problem. 

The other problem we study, sequence alignment, is the fundamental problem in
computational biology, and many methods for comparing genomes rely on sequence
alignment. Since biases in the alignment introduce artefacts in the results of
these methods, there is need to develop algorithms for producing sequence
alignment with as low error rate as possible. The goal is to search for
corresponding  parts of the sequences and them into same position in the
alignment.  To choose the biologically correct alignment, we optimize some
scoring scheme. We will consider scoring schemes which are  defined using
\abbreviation{pair hidden Markov models}{pHMM}. A pHMM generates pairs of
sequences along with their alignment (an alignment is defined by the state
path).  This model is an extension of HMM. 


In the fourth chapter we propose tractable method for aligning sequence with
tandem repeats. Tandem repeats consists from consecutive copies (not exact) of
certain motif (sort genomic sequence). Tandem repeats causes problems with
sequence alignments because it is hard to distinguish between repetitions.
We extend traditional pHMM model for sequence alignment by additional states
modeling tandem repeats. We also propose new decoding algorithms tailored to
this model. We show on the simulated data, that new model and decoding methods
decreased the error rate and near the border of tandem repeats the error rate
was decreased significantly.

\section{Biological Background}\label{SECTION:BIOINTRO}

In this section we review several biological terms that will be needed. More
information about DNA, proteins and genes can be found in
\cite{BiologyForDummies, UnderstandingBioinformatics}. Practically every cell of living
organisms contains one or several \firstUseOf{DNA} molecules. DNA is a double
stranded molecule consisting of two long sequences (strands) of
\firstUseOf{nucleotides} (nucleotides are also referred to as bases or
\firstUseOf{residues}). There are four types of nucleotides in DNA: adenosine,
cytosine, guanine, and thymine represented by letters $A,C,G$ and $T$
respectively. In RNA nucleotide $T$ is replaced with uracil, denoted by $U$.
The nucleotides at the same position in
the two strands are connected by hydrogen bonds and are complementary: $A$ is
always connected with $T$ and $C$ is always connected with $G$. Therefore we
can represent DNA molecule by a sequence over alphabet $\{A,C,G,T\}$ since the
complementary strand can be easily computed.

Some parts of DNA encode \firstUseOf{proteins}. Proteins play an important role in cell
biology since  they regulate many processes in the cell and are catalysts to
many chemical reactions. Proteins are sequences of \firstUseOf{amino acid}
molecules. There are $20$ amino acids that can be encoded in DNA. Parts of DNA
that encode proteins are called \firstUseOf{genes} (gene is ``substring'' of
DNA that will be translated into one protein). We refer to the DNA
sequences of the organism as to its \firstUseOf{genome}.

The rational behind sequence alignment to represent the evolution of two
sequences. A according to the evolution theory, currently living organisms
evolved from a single common ancestor through small changes in their genomes.
There are many types of changes.  Substitutions change  a nucleotide at some
position to another nucleotide.  Insertions and deletions add or remove parts
of the genomic sequence. Other changes includes duplications (a region of a
sequence is copied into a different part of the genome), inversions (a region
of the sequence is inverted), and even large genome rearrangements (the large
regions  change their position within genome). 

The speciation is an event, when a new species is created. This happens mostly
due to physical separation of populations of the same species, and each
population evolves differently to the point, that  they form
different species. We can represent the evolution of species using a binary
tree. Each leaf represents a current organism, each internal vertex represents
a speciation event, and the root represents the common ancestor of all species in
the tree. The branch lengths usually correspond to the amount of changes in
the genome, or to the time. 

We say that two parts of the biological sequences $X$ and $Y$ are
\firstUseOf{homologous}, if they originate from some same sequence in the
common ancestor of $X$ and $Y$. Unless the evolutionary distance (time, number
of mutations) is too high, the homologous sequences has higher sequence
similarity than non-homologous sequences. However the hight evolutionary
distance may cause the sequence to diverge into a state, that the sequence
similarity is as low as for two random sequences.

As we mentioned in previous section, an alignment as an data structure that
represents sequences and their relation through some evolutionary changes
(substitutions, insertions and deletions).  It is obtained by adding gap
symbols ($-$) into the sequences so that they have the same length and form a
2-dimensional array or a matrix, where each sequence is in its own row. When
aligning two related sequences (they share common ancestor), we want to
homologous parts of the sequences into same columns.

Additionally, we distinguish between two types of homologs: orthologs and
paralogs. The orthologs are two different sequences that originated from the
common ancestor sequence by a speciation event. The paralogs are two different
sequences that evolved by duplication event within the same organism. The
distinction is important when aligning repetitive regions; we want to align
orthologous regions, but the paralogous regions are very similar and it is very
hard to distinguish between paralogous and orthologous regions.

\section{Notation}

In this section we summarize notation used in the following
chapters.

All sequences, members of sets, vectors, and rows and columns of matrices will
be indexed from $0$. We will use mostly right-open intervals: $I=[a,b)$ means
that $a\in I$, but $b\notin I$. 

The element at the $k$-th position (zero based) of string (or sequence) $s$ will
be written as $s[k]$. The substring $s[i]s[i+1]\dots s[j-1]$ is denoted
$s[i:j]$.  If $n$ is the length of the string $s$ then $s[:i]$ is equivalent to
$s[0:i]$ and $s[i:]$ is equivalent to $s[i:n]$.  We will use the terms sequence
and string interchangeably.

Let $M$ be a matrix. Then $M[i,j]$ is the element from the $i$-th row and $j$-th
column of $M$ (indices are zero based). Similarly as for strings, submatrix
$M[i:j,k:l]$ is a matrix consisting from the intersection of rows $i,i+1,\dots,
j-1$ with columns $k,k+1,\dots,l-1$. If $M$ is of size $n\times m$ then
$M[:i,j:]$ is equivalent to $M[0:i,j:m]$.  The term $M[i,:]$ is equivalent to
$M[i,0:m]$ which is the $i$-th row of $M$.
